import logging
import asyncio
import os
import time
from aiogram import Bot, Dispatcher, F
from aiogram.client.session.aiohttp import AiohttpSession
from aiogram.client.bot import DefaultBotProperties
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, ReplyKeyboardMarkup, KeyboardButton, ContentType
from aiogram.filters import Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.utils.exceptions import ChatMemberNotParticipant
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from telethon.tl.types import InputPeerChannel, Channel
from telethon import TelegramClient
from telethon.errors import SessionPasswordNeededError
from telethon.errors.rpcerrorlist import PhoneNumberInvalidError
from datetime import datetime, timedelta
import random
import aiosqlite

API_TOKEN = '8024335015:AAEeQ6cZSHJdvSXhMzyubyth1UHOv2mFtpM'
ADMIN_ID = 1083294848
TELEGRAM_API_ID = '23422308'
TELEGRAM_API_HASH = '1da8d8d190e8fb59531b28258d1ed64c'
BUY_LINK = "https://t.me/sirdebar"
CHANNEL_ID = '@diablocatos'

if not os.path.exists('temp_photos'):
    os.makedirs('temp_photos')

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)

session = AiohttpSession()
bot = Bot(token=API_TOKEN, session=session, default=DefaultBotProperties(parse_mode='HTML'))
dp = Dispatcher(storage=MemoryStorage())

# ================== –ö–ù–û–ü–ö–ò –î–õ–Ø –ü–û–î–ü–ò–°–ö–ò ===================

def get_subscription_keyboard():
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text='üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è', url=f'https://t.me/{CHANNEL_ID}')],
        [InlineKeyboardButton(text='‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É', callback_data='check_subscription')]
    ])
    return keyboard

# ================== –°–û–°–¢–û–Ø–ù–ò–Ø ===================

class AccountStates(StatesGroup):
    waiting_for_phone = State()
    waiting_for_code = State()
    waiting_for_password = State()

class MailingStates(StatesGroup):
    waiting_for_account = State()
    choosing_chats = State()
    waiting_for_messages = State()
    waiting_for_delay = State()
    waiting_for_action = State()

class KeyStates(StatesGroup):
    waiting_for_key = State()
    waiting_for_days = State()

# ================== –ú–ï–ù–Æ ===================

def get_new_user_menu():
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text='üõí –ö—É–ø–∏—Ç—å –¥–æ—Å—Ç—É–ø', url=BUY_LINK)],
            [KeyboardButton(text='üîë –í–≤–µ—Å—Ç–∏ –∫–ª—é—á –¥–æ—Å—Ç—É–ø–∞')]
        ],
        resize_keyboard=True
    )
    return keyboard

def get_user_menu():
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text='üìã –ü—Ä–æ—Ñ–∏–ª—å')],
            [KeyboardButton(text='üóùÔ∏è –î–æ–±–∞–≤–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç')],
            [KeyboardButton(text='üì§ –ù–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞')],
            [KeyboardButton(text='‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏')] 
        ],
        resize_keyboard=True
    )
    return keyboard

def get_admin_menu():
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text='üîë –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞')],
            [KeyboardButton(text='üìã –ü—Ä–æ—Ñ–∏–ª—å')],
            [KeyboardButton(text='üóùÔ∏è –î–æ–±–∞–≤–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç')],
            [KeyboardButton(text='üì§ –ù–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞')],
            [KeyboardButton(text='‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏')] 
        ],
        resize_keyboard=True
    )
    return keyboard

# ================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ë–î ===================

async def init_db():
    async with aiosqlite.connect('bot_database.db') as db:
        await db.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY, 
                name TEXT, 
                subscription_expires DATETIME
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS accounts (
                account_id INTEGER PRIMARY KEY AUTOINCREMENT, 
                user_id INTEGER, 
                phone_number TEXT, 
                session TEXT
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS keys (
                key TEXT PRIMARY KEY, 
                valid_until DATETIME, 
                days INTEGER
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS mailings (
                mailing_id INTEGER PRIMARY KEY AUTOINCREMENT, 
                user_id INTEGER, 
                chats TEXT, 
                messages TEXT, 
                status TEXT, 
                sent_messages INTEGER, 
                start_time DATETIME
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS chats (
                chat_id INTEGER PRIMARY KEY, 
                account_id INTEGER, 
                title TEXT
            )
        ''')
        await db.commit()

# ================== –ü–†–û–§–ò–õ–¨ –ò –ü–û–î–ü–ò–°–ö–ê ===================

@dp.message(F.text == "üìã –ü—Ä–æ—Ñ–∏–ª—å")
async def show_profile(message: Message):
    user_id = message.from_user.id

    async with aiosqlite.connect('bot_database.db') as db:
        if user_id == ADMIN_ID:
            async with db.execute('SELECT COUNT(*) FROM users WHERE subscription_expires > ?', 
                                  (datetime.now().strftime("%Y-%m-%d %H:%M:%S"),)) as cursor:
                active_subscribers = await cursor.fetchone()
                active_subscribers = active_subscribers[0] or 0

            async with db.execute('SELECT SUM(sent_messages) FROM mailings') as cursor:
                total_mailings = await cursor.fetchone()
                total_mailings = total_mailings[0] or 0

            async with db.execute('SELECT SUM(sent_messages) FROM mailings WHERE user_id = ?', (ADMIN_ID,)) as cursor:
                personal_mailings = await cursor.fetchone()
                personal_mailings = personal_mailings[0] or 0

            await message.answer(
                "<b>üëë –ü—Ä–æ—Ñ–∏–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:</b>\n\n"
                f"<b>–ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤:</b> {active_subscribers}\n\n"
                f"<b>–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Å–µ—Ö —Ä–∞—Å—Å—ã–ª–æ–∫:</b> {total_mailings}\n\n"
                f"<b>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—à–∏—Ö —Ä–∞—Å—Å—ã–ª–æ–∫:</b> {personal_mailings}"
            )
        else:
            async with db.execute('SELECT name, subscription_expires FROM users WHERE user_id = ?', (user_id,)) as cursor:
                result = await cursor.fetchone()

            if not result:
                await message.answer("<b>‚õî –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏.</b>")
                return

            name, subscription_expires = result
            async with db.execute('SELECT SUM(sent_messages) FROM mailings WHERE user_id = ?', (user_id,)) as cursor:
                mailing_count = await cursor.fetchone()
                mailing_count = mailing_count[0] or 0

            await message.answer(
                f"<b>üë§ –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å:</b>\n"
                f"<b>–ò–º—è:</b> {name}\n\n"
                f"<b>–û—Å—Ç–∞–≤—à–∏–π—Å—è —Å—Ä–æ–∫ –ø–æ–¥–ø–∏—Å–∫–∏:</b> {subscription_expires}\n\n"
                f"<b>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—à–∏—Ö —Ä–∞—Å—Å—ã–ª–æ–∫:</b> {mailing_count}"
            )

# ================== –í–í–û–î –ö–õ–Æ–ß–ê –î–û–°–¢–£–ü–ê ===================

@dp.message(F.text == "üîë –í–≤–µ—Å—Ç–∏ –∫–ª—é—á –¥–æ—Å—Ç—É–ø–∞")
async def ask_for_key(message: Message, state: FSMContext):
    await message.answer("<b>üîë –í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –¥–æ—Å—Ç—É–ø–∞.</b>")
    await state.set_state(KeyStates.waiting_for_key)

@dp.message(KeyStates.waiting_for_key)
async def process_key(message: Message, state: FSMContext):
    key = message.text
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT valid_until, days FROM keys WHERE key = ?', (key,)) as cursor:
            result = await cursor.fetchone()

    if result:
        valid_until, days = result
        if datetime.strptime(valid_until, "%Y-%m-%d %H:%M:%S") > datetime.now():
            subscription_expires = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
            async with aiosqlite.connect('bot_database.db') as db:
                await db.execute('INSERT OR REPLACE INTO users (user_id, name, subscription_expires) VALUES (?, ?, ?)',
                                (message.from_user.id, message.from_user.full_name, subscription_expires))
                await db.commit()

            await message.answer("<b>‚úÖ –ö–ª—é—á –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!</b> –í–∞—à –¥–æ—Å—Ç—É–ø <b>–ø—Ä–æ–¥–ª–µ–Ω</b>.", reply_markup=get_user_menu())
        else:
            await message.answer("<b>‚õî –ö–ª—é—á –∏—Å—Ç–µ–∫.</b>")
    else:
        await message.answer("<b>‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á.</b>")
    
    await state.clear()

# ================== –ü–û–ö–£–ü–ö–ê –î–û–°–¢–£–ü–ê ===================

@dp.message(F.text == "üõí –ö—É–ø–∏—Ç—å –¥–æ—Å—Ç—É–ø")
async def buy_access(message: Message):
    admin_username = "sirdebar"
    await message.answer(f"<b>–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ —É @{admin_username}!</b>")

# ================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ê–ö–ö–ê–£–ù–¢–ê–ú–ò ===================

@dp.message(F.text == "‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏")
async def manage_accounts(message: Message):
    user_id = message.from_user.id
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT account_id, phone_number FROM accounts WHERE user_id = ?', (user_id,)) as cursor:
            accounts = await cursor.fetchall()

        if not accounts:
            await message.answer("<b>–£ –≤–∞—Å –Ω–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤.</b>")
            return

        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=f"–£–¥–∞–ª–∏—Ç—å {account[1]}", callback_data=f"delete_account_{account[0]}")]
            for account in accounts
        ])
        await message.answer("<b>–í—ã–±–µ—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:</b>", reply_markup=keyboard)

# ================== –£–î–ê–õ–ï–ù–ò–ï –ê–ö–ö–ê–£–ù–¢–ê ===================

@dp.callback_query(F.data.startswith("delete_account_"))
async def confirm_account_deletion(callback_query: CallbackQuery):
    account_id = int(callback_query.data.split("_")[-1])
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT phone_number FROM accounts WHERE account_id = ?', (account_id,)) as cursor:
            phone_number = await cursor.fetchone()
            phone_number = phone_number[0]

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–î–∞", callback_data=f"confirm_delete_{account_id}")],
        [InlineKeyboardButton(text="–ù–µ—Ç", callback_data="cancel_deletion")]
    ])
    
    await callback_query.message.edit_text(
        f"<b>–í—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç —Å –Ω–æ–º–µ—Ä–æ–º {phone_number}?</b>",
        reply_markup=keyboard
    )

@dp.callback_query(F.data == "cancel_deletion")
async def cancel_deletion(callback_query: CallbackQuery):
    await callback_query.message.edit_text("<b>–£–¥–∞–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.</b>")
    await callback_query.message.answer("<b>–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.</b>", reply_markup=get_user_menu())

@dp.callback_query(F.data.startswith("confirm_delete_"))
async def delete_account(callback_query: CallbackQuery):
    account_id = int(callback_query.data.split("_")[-1])
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT phone_number FROM accounts WHERE account_id = ?', (account_id,)) as cursor:
            account = await cursor.fetchone()
            phone_number = account[0]
            session_path = f'sessions/{phone_number}.session'

        client = TelegramClient(session_path, TELEGRAM_API_ID, TELEGRAM_API_HASH)
        await client.connect()

        if client.is_connected():
            await client.disconnect()

        await db.execute('DELETE FROM accounts WHERE account_id = ?', (account_id,))
        await db.commit()

    try:
        if os.path.exists(session_path):
            os.remove(session_path)
    except PermissionError as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ —Å–µ—Å—Å–∏–∏: {e}")
        await callback_query.message.answer(f"<b>–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–µ—Å—Å–∏—é –¥–ª—è –Ω–æ–º–µ—Ä–∞ {phone_number}.</b>")
        return

    await callback_query.message.edit_text(
        f"<b>–ê–∫–∫–∞—É–Ω—Ç —Å –Ω–æ–º–µ—Ä–æ–º {phone_number} –±—ã–ª —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω.</b>",
        reply_markup=None
    )
    await callback_query.message.answer("<b>–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.</b>", reply_markup=get_user_menu())

# ================== –ü–†–û–§–ò–õ–¨ –ò –ü–û–î–ü–ò–°–ö–ê ===================

@dp.message(Command(commands=["start"]))
async def start_bot(message: Message, state: FSMContext):
    user_id = message.from_user.id
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–ø–∏—Å–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –∫–∞–Ω–∞–ª
        member = await bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
        if member.status == 'member' or member.status == 'administrator' or member.status == 'creator':
            await give_access(message)
        else:
            raise ChatMemberNotParticipant  # –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω, –±—Ä–æ—Å–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
    except ChatMemberNotParticipant:
        await ask_for_subscription(message)

# ================== –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò –ü–†–ò –ù–ê–ñ–ê–¢–ò–ò –ù–ê –ö–ù–û–ü–ö–£ ===================

@dp.callback_query(F.data == "check_subscription")
async def check_subscription(callback_query: CallbackQuery):
    user_id = callback_query.from_user.id
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–ø–∏—Å–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ –∫–∞–Ω–∞–ª
        member = await bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
        if member.status == 'member' or member.status == 'administrator' or member.status == 'creator':
            await callback_query.message.delete()  # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–æ–¥–ø–∏—Å–∫–∏
            await give_access(callback_query.message)
        else:
            raise ChatMemberNotParticipant  # –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω, –ø–æ–≤—Ç–æ—Ä—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    except ChatMemberNotParticipant:
        await ask_for_subscription(callback_query.message)

# ================== –ü–†–ï–î–õ–ê–ì–ê–ï–ú –ü–û–î–ü–ò–°–ê–¢–¨–°–Ø ===================

async def ask_for_subscription(message: Message):
    await message.answer(
        "–ü–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –±–æ—Ç–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª.",
        reply_markup=get_subscription_keyboard()
    )

# ================== –ü–†–ï–î–û–°–¢–ê–í–õ–Ø–ï–ú –î–û–°–¢–£–ü –ü–û–°–õ–ï –ü–†–û–í–ï–†–ö–ò ===================

async def give_access(message: Message):
    user_id = message.from_user.id
    if user_id == ADMIN_ID:
        await message.answer("<b>üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –∞–¥–º–∏–Ω!</b>", reply_markup=get_admin_menu())
    else:
        async with aiosqlite.connect('bot_database.db') as db:
            async with db.execute('SELECT subscription_expires FROM users WHERE user_id = ?', (user_id,)) as cursor:
                result = await cursor.fetchone()

        if result:
            subscription_expires = result[0]
            if datetime.strptime(subscription_expires, "%Y-%m-%d %H:%M:%S") > datetime.now():
                await message.answer("<b>üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b> –í–∞—à –¥–æ—Å—Ç—É–ø <b>–∞–∫—Ç–∏–≤–µ–Ω</b>.", reply_markup=get_user_menu())
            else:
                await message.answer("<b>‚è≥ –í–∞—à –¥–æ—Å—Ç—É–ø –∏—Å—Ç–µ–∫.</b> –í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂–µ.", reply_markup=get_new_user_menu())
        else:
            await message.answer("<b>üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b> –í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂–µ.", reply_markup=get_new_user_menu())

# ================== –ï–ñ–ï–î–ù–ï–í–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò ===================

async def check_subscriptions():
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT user_id FROM users') as cursor:
            users = await cursor.fetchall()

        for user in users:
            user_id = user[0]
            try:
                member = await bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
                if member.status != 'member':
                    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–ø–∏—Å–∞–ª—Å—è, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                    await bot.send_message(user_id, "‚õî –í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç –∫–∞–Ω–∞–ª–∞. –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å —Å–Ω–æ–≤–∞, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º.", reply_markup=get_subscription_keyboard())
            except ChatMemberNotParticipant:
                # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±—ã–ª –∏—Å–∫–ª—é—á–µ–Ω –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω
                await bot.send_message(user_id, "‚õî –í—ã –±—ã–ª–∏ –∏—Å–∫–ª—é—á–µ–Ω—ã –∏–∑ –∫–∞–Ω–∞–ª–∞. –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å —Å–Ω–æ–≤–∞, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º.", reply_markup=get_subscription_keyboard())

# –ó–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
async def scheduled_subscription_check():
    while True:
        await check_subscriptions()
        await asyncio.sleep(86400)  # –ò–Ω—Ç–µ—Ä–≤–∞–ª 1 –¥–µ–Ω—å (86400 —Å–µ–∫—É–Ω–¥)
        
# ================== –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò ===================

async def check_subscription_expiration():
    while True:
        async with aiosqlite.connect('bot_database.db') as db:
            async with db.execute('SELECT user_id, subscription_expires FROM users') as cursor:
                users = await cursor.fetchall()

            for user_id, subscription_expires in users:
                if datetime.strptime(subscription_expires, "%Y-%m-%d %H:%M:%S") < datetime.now():
                    await bot.send_message(
                        user_id,
                        "<b>‚è≥ –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å.</b>\n"
                        "–ü—Ä–æ–¥–ª–∏—Ç—å –¥–æ—Å—Ç—É–ø –≤—ã –º–æ–∂–µ—Ç–µ —É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞."
                    )
                    await bot.send_message(
                        user_id,
                        "<b>–ü—Ä–æ–¥–ª–∏—Ç—å –¥–æ—Å—Ç—É–ø –≤—ã –º–æ–∂–µ—Ç–µ —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ.</b>",
                        reply_markup=get_new_user_menu()
                    )
                    await db.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
                    await db.commit()

        await asyncio.sleep(3600)

# ================== –î–û–ë–ê–í–õ–ï–ù–ò–ï –ê–ö–ö–ê–£–ù–¢–ê ===================

@dp.message(F.text == "üóùÔ∏è –î–æ–±–∞–≤–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç")
async def add_account(message: Message, state: FSMContext):
    await message.answer("<b>üìû –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–≤ —Ñ–æ—Ä–º–∞—Ç–µ 9123456789).</b>")
    await state.set_state(AccountStates.waiting_for_phone)

@dp.message(AccountStates.waiting_for_phone)
async def process_phone(message: Message, state: FSMContext):
    phone_number = message.text.strip()
    
    if not phone_number.isdigit() or len(phone_number) < 10:
        await message.answer("<b>‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä.</b>")
        await state.clear()
        return
    
    user_id = message.from_user.id

    session_path = f'sessions/{phone_number}.session'
    if not os.path.exists('sessions'):
        os.mkdir('sessions')

    client = TelegramClient(session_path, TELEGRAM_API_ID, TELEGRAM_API_HASH)
    
    try:
        await client.connect()

        if not await client.is_user_authorized():
            await client.send_code_request(phone_number)
            await message.answer(f"<b>üì≤ –ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –Ω–æ–º–µ—Ä {phone_number}.</b> –í–≤–µ–¥–∏—Ç–µ –µ–≥–æ.")
            await state.update_data(phone_number=phone_number, client=client)
            await state.set_state(AccountStates.waiting_for_code)
        else:
            await message.answer("<b>‚úÖ –≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω.</b>")
            await state.clear()
    
    except PhoneNumberInvalidError:
        await message.answer(f"<b>‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞: {phone_number}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä.</b>")
        await state.clear()
        return
    
    except Exception as e:
        await message.answer(f"<b>‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞: {e}</b>")
        await state.clear()
        return


@dp.message(AccountStates.waiting_for_code)
async def process_code(message: Message, state: FSMContext):
    code = message.text
    user_data = await state.get_data()
    phone_number = user_data['phone_number']
    client = user_data['client']

    try:
        await client.sign_in(phone_number, code)
        session_string = client.session.save()
        async with aiosqlite.connect('bot_database.db') as db:
            await db.execute('INSERT INTO accounts (user_id, phone_number, session) VALUES (?, ?, ?)', 
                             (message.from_user.id, phone_number, session_string))
            await db.commit()

        await message.answer(f"<b>üóùÔ∏è –ê–∫–∫–∞—É–Ω—Ç {phone_number} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω.</b>")
        await state.clear()

    except SessionPasswordNeededError:
        await message.answer("<b>üîê –≠—Ç–æ—Ç –∞–∫–∫–∞—É–Ω—Ç –∑–∞—â–∏—â–µ–Ω –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π. –í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:</b>")
        await state.update_data(client=client)
        await state.set_state(AccountStates.waiting_for_password)

    except Exception as e:
        await message.answer(f"<b>‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:</b> {e}")
        await state.clear()

@dp.message(AccountStates.waiting_for_password)
async def process_password(message: Message, state: FSMContext):
    password = message.text
    user_data = await state.get_data()
    client = user_data['client']

    try:
        await client.sign_in(password=password)
        phone_number = user_data['phone_number']
        session_string = client.session.save()
        async with aiosqlite.connect('bot_database.db') as db:
            await db.execute('INSERT INTO accounts (user_id, phone_number, session) VALUES (?, ?, ?)', 
                             (message.from_user.id, phone_number, session_string))
            await db.commit()

        await message.answer(f"<b>üóùÔ∏è –ê–∫–∫–∞—É–Ω—Ç {phone_number} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω —Å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π.</b>")
        await state.clear()

    except Exception as e:
        await message.answer(f"<b>‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:</b> {e}")
        await state.set_state(AccountStates.waiting_for_password)

# ================== –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–õ–Æ–ß–ê –î–õ–Ø –ê–î–ú–ò–ù–ê ===================

@dp.message(F.text == "üîë –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞")
async def ask_for_days(message: Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        await message.answer("<b>‚õî –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.</b>")
        return
    await message.answer("<b>üìÖ –£–∫–∞–∂–∏—Ç–µ —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–ª—é—á–∞ –≤ –¥–Ω—è—Ö:</b>")
    await state.set_state(KeyStates.waiting_for_days)

@dp.message(KeyStates.waiting_for_days)
async def generate_key(message: Message, state: FSMContext):
    try:
        days = int(message.text)
        if days <= 0:
            await message.answer("<b>‚ö†Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.</b>")
            return

        key = generate_random_key()
        valid_until = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")

        async with aiosqlite.connect('bot_database.db') as db:
            await db.execute('INSERT INTO keys (key, valid_until, days) VALUES (?, ?, ?)', (key, valid_until, days))
            await db.commit()

        await message.answer(f"<b>üîë –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –Ω–æ–≤—ã–π –∫–ª—é—á –Ω–∞ {days} –¥–Ω–µ–π:</b> {key}")
        await state.clear()

    except ValueError:
        await message.answer("<b>‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.</b>")

def generate_random_key():
    return ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=8))

# ================== –†–ê–°–°–´–õ–ö–ê –°–û–û–ë–©–ï–ù–ò–ô ===================

@dp.message(F.text == "üì§ –ù–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞")
async def new_mailing(message: Message, state: FSMContext):
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT account_id, phone_number FROM accounts WHERE user_id = ?', (message.from_user.id,)) as cursor:
            accounts = await cursor.fetchall()

    if not accounts:
        await message.answer("<b>‚ùå –°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.</b>")
        return

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"–ê–∫–∫–∞—É–Ω—Ç {account[1]}", callback_data=f"choose_account_{account[0]}")]
        for account in accounts
    ])

    await message.answer("<b>üìã –í—ã–±–µ—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏:</b>", reply_markup=keyboard)
    await state.set_state(MailingStates.waiting_for_account)

@dp.callback_query(F.data.startswith("choose_account_"))
async def choose_account(callback_query: CallbackQuery, state: FSMContext):
    account_id = int(callback_query.data.split("_")[-1])

    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT phone_number, session FROM accounts WHERE account_id = ?', (account_id,)) as cursor:
            account = await cursor.fetchone()
            phone_number, session_string = account

    client = TelegramClient(f'sessions/{phone_number}', TELEGRAM_API_ID, TELEGRAM_API_HASH)
    await client.connect()
    if not await client.is_user_authorized():
        await callback_query.message.answer("<b>–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.</b>")
        await state.clear()
        return

    await get_group_chats(client, account_id)
    await client.disconnect()

    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT chat_id, title FROM chats WHERE account_id = ?', (account_id,)) as cursor:
            chats = await cursor.fetchall()

    await state.update_data(account_id=account_id)
    await show_chat_selection(callback_query.message, chats, state, page=0)

async def show_chat_selection(message, chats, state, page=0):
    per_page = 10
    start = page * per_page
    end = start + per_page
    current_page_chats = chats[start:end]

    user_data = await state.get_data()
    selected_chats = user_data.get('selected_chats', [chat[0] for chat in chats])

    buttons = []
    for chat in current_page_chats:
        status = "‚úÖ" if chat[0] in selected_chats else "‚ùå"
        buttons.append([InlineKeyboardButton(text=f"{chat[1]} {status}", callback_data=f"toggle_chat_{chat[0]}")])

    if len(chats) > per_page:
        pagination_buttons = []
        if page > 0:
            pagination_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"prev_page_{page-1}"))
        if end < len(chats):
            pagination_buttons.append(InlineKeyboardButton(text="‚û°Ô∏è –í–ø–µ—Ä–µ–¥", callback_data=f"next_page_{page+1}"))
        buttons.append(pagination_buttons)

    buttons.append([InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_chats")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)

    await message.answer("<b>–í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç—ã –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏:</b>", reply_markup=keyboard)
    await state.update_data(selected_chats=selected_chats, all_chats=chats, page=page)

@dp.callback_query(F.data.startswith("toggle_chat_"))
async def toggle_chat(callback_query: CallbackQuery, state: FSMContext):
    chat_id = int(callback_query.data.split("_")[-1])
    user_data = await state.get_data()
    selected_chats = user_data['selected_chats']

    if chat_id in selected_chats:
        selected_chats.remove(chat_id)
    else:
        selected_chats.append(chat_id)

    await state.update_data(selected_chats=selected_chats)

    chats = user_data['all_chats']
    page = user_data['page']
    await show_chat_selection(callback_query.message, chats, state, page=page)

@dp.callback_query(F.data.startswith("next_page_") | F.data.startswith("prev_page_"))
async def paginate_chats(callback_query: CallbackQuery, state: FSMContext):
    user_data = await state.get_data()
    chats = user_data['all_chats']
    page = int(callback_query.data.split("_")[-1])

    await show_chat_selection(callback_query.message, chats, state, page)

@dp.callback_query(F.data == "confirm_chats")
async def confirm_chats(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.message.answer("<b>üí¨ –í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.</b>")
    await state.set_state(MailingStates.waiting_for_messages)

@dp.message(MailingStates.waiting_for_messages, F.text | F.photo)
async def process_messages(message: Message, state: FSMContext):
    if message.photo:
        photo = message.photo[-1]
        file_info = await bot.get_file(photo.file_id)
        file_path = file_info.file_path
        downloaded_file = await bot.download_file(file_path)

        photo_path = f"temp_photos/{photo.file_id}.jpg"
        os.makedirs("temp_photos", exist_ok=True)
        with open(photo_path, 'wb') as new_file:
            new_file.write(downloaded_file.getvalue())

        await state.update_data(photo=photo_path)
        if message.caption:
            await state.update_data(messages=message.caption)
        else:
            await state.update_data(messages=None)

    elif message.text:
        await state.update_data(messages=message.text)
        await state.update_data(photo=None)

    await message.answer("<b>‚è≥ –í–≤–µ–¥–∏—Ç–µ –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 5—Å, 5–º, 5—á, –º–∞–∫—Å–∏–º—É–º 5 —á–∞—Å–æ–≤, –º–∏–Ω–∏–º—É–º 5 —Å–µ–∫—É–Ω–¥).</b>")
    await state.set_state(MailingStates.waiting_for_delay)

def parse_delay(delay_str):
    if delay_str.endswith('—Å'):
        return int(delay_str[:-1])
    elif delay_str.endswith('–º'):
        return int(delay_str[:-1]) * 60
    elif delay_str.endswith('—á'):
        return int(delay_str[:-1]) * 3600
    else:
        raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–¥–µ—Ä–∂–∫–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å (—Å–µ–∫—É–Ω–¥—ã), –º (–º–∏–Ω—É—Ç—ã), —á (—á–∞—Å—ã).")

@dp.message(MailingStates.waiting_for_delay)
async def process_delay(message: Message, state: FSMContext):
    try:
        delay = parse_delay(message.text)
        if delay < 5 or delay > 18000:
            raise ValueError

        await state.update_data(delay=delay)

        user_data = await state.get_data()
        account_id = user_data['account_id']
        selected_chats = user_data['selected_chats']
        messages = user_data.get('messages')
        photo = user_data.get('photo')

        if not messages and not photo:
            await message.answer("<b>‚ö†Ô∏è –í—ã –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏–ª–∏ —Ç–µ–∫—Å—Ç –∏–ª–∏ —Ñ–æ—Ç–æ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.</b>")
            return

        asyncio.create_task(start_mailing(account_id, selected_chats, messages, photo, delay, message.from_user.id))
        await message.answer("<b>üöÄ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞!</b> –°—Ç–∞—Ç—É—Å: <b>–ê–∫—Ç–∏–≤–Ω–∞</b>", reply_markup=get_mailing_control_keyboard(paused=False))
        await state.set_state(MailingStates.waiting_for_action)

    except ValueError:
        await message.answer("<b>‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –∑–∞–¥–µ—Ä–∂–∫—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ 5—Å, 5–º, 5—á (–Ω–µ –º–µ–Ω–µ–µ 5 —Å–µ–∫—É–Ω–¥ –∏ –Ω–µ –±–æ–ª–µ–µ 5 —á–∞—Å–æ–≤).</b>")

def get_mailing_control_keyboard(paused=False):
    buttons = []
    if paused:
        buttons.append([InlineKeyboardButton(text="‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å", callback_data="resume_mailing")])
    else:
        buttons.append([InlineKeyboardButton(text="‚è∏ –ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", callback_data="pause_mailing")])
    buttons.append([InlineKeyboardButton(text="‚èπ –ó–∞–∫–æ–Ω—á–∏—Ç—å", callback_data="stop_mailing")])

    return InlineKeyboardMarkup(inline_keyboard=buttons)

async def send_messages(account_id, chats, messages, delay, user_id):
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT phone_number, session FROM accounts WHERE account_id = ?', (account_id,)) as cursor:
            account = await cursor.fetchone()

    session_path = f'sessions/{account[0]}.session'
    client = TelegramClient(session_path, TELEGRAM_API_ID, TELEGRAM_API_HASH)
    await client.connect()

    sent_count = 0

    for chat in chats:
        try:
            await client.send_message(chat, messages)
            sent_count += 1
            async with aiosqlite.connect('bot_database.db') as db:
                await db.execute(
                    'INSERT INTO mailings (user_id, chats, messages, status, sent_messages, start_time) VALUES (?, ?, ?, ?, ?, ?)',
                    (user_id, ','.join(str(c) for c in chats), '\n'.join(messages), 'active', sent_count, datetime.now().isoformat())
                )
                await db.commit()

            await asyncio.sleep(delay)

        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç {chat}: {e}")

    await client.disconnect()

# ================== –ü–ê–†–°–ò–ù–ì –ß–ê–¢–û–í ===================

async def get_group_chats(client, account_id):
    dialogs = await client.get_dialogs()
    async with aiosqlite.connect('bot_database.db') as db:
        for dialog in dialogs:
            if isinstance(dialog.entity, Channel) and dialog.entity.megagroup:
                chat_id = dialog.id
                title = dialog.title
                await db.execute('INSERT OR REPLACE INTO chats (chat_id, account_id, title) VALUES (?, ?, ?)', 
                                (chat_id, account_id, title))
        await db.commit()

# ================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –†–ê–°–°–´–õ–ö–û–ô ===================

active_mailings = {}

# ================== –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –†–ê–°–°–´–õ–ö–ò ===================

async def start_mailing(account_id, chats, messages, photo, delay, user_id):
    active_mailings[user_id] = True
    async with aiosqlite.connect('bot_database.db') as db:
        async with db.execute('SELECT phone_number, session FROM accounts WHERE account_id = ?', (account_id,)) as cursor:
            account = await cursor.fetchone()

    session_path = f'sessions/{account[0]}.session'
    client = TelegramClient(session_path, TELEGRAM_API_ID, TELEGRAM_API_HASH)
    await client.connect()

    sent_count = 0

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –∑–∞–¥–µ—Ä–∂–∫–∏ –≤–æ –≤—Å–µ —á–∞—Ç—ã
    for chat_id in chats:
        if not active_mailings.get(user_id):
            break
        try:
            if photo:
                await client.send_file(chat_id, photo, caption=messages if messages else "")
            else:
                await client.send_message(chat_id, messages)
            sent_count += 1
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ —á–∞—Ç {chat_id}: {e}")

    # –ü—Ä–∏–º–µ–Ω—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ —Ü–∏–∫–ª–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏
    while active_mailings.get(user_id):
        for chat_id in chats:
            if not active_mailings.get(user_id):
                break
            try:
                if photo:
                    await client.send_file(chat_id, photo, caption=messages if messages else "")
                else:
                    await client.send_message(chat_id, messages)
                sent_count += 1

                await asyncio.sleep(delay)  # –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –≤ —Å–ª–µ–¥—É—é—â–∏–π —á–∞—Ç
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ —á–∞—Ç {chat_id}: {e}")

    await client.disconnect()

@dp.callback_query(F.data == "pause_mailing")
async def pause_mailing(callback_query: CallbackQuery, state: FSMContext):
    user_id = callback_query.from_user.id
    if active_mailings.get(user_id):
        active_mailings[user_id] = False
        await callback_query.message.edit_text("<b>–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏:</b> –ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞", reply_markup=get_mailing_control_keyboard(paused=True))

@dp.callback_query(F.data == "resume_mailing")
async def resume_mailing(callback_query: CallbackQuery, state: FSMContext):
    user_data = await state.get_data()

    account_id = user_data.get('account_id')
    selected_chats = user_data.get('selected_chats')
    messages = user_data.get('messages')
    photo = user_data.get('photo')
    delay = user_data.get('delay')

    if photo and not os.path.exists(photo):
        await callback_query.message.edit_text("<b>–û—à–∏–±–∫–∞:</b> –§–æ—Ç–æ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –±—ã–ª–æ —É–¥–∞–ª–µ–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –Ω–æ–≤–æ–µ.")
        return

    if not account_id or not selected_chats or not delay:
        await callback_query.message.edit_text("<b>–û—à–∏–±–∫–∞:</b> –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–∞—Å—Å—ã–ª–∫–∏.")
        return

    active_mailings[callback_query.from_user.id] = True
    asyncio.create_task(start_mailing(account_id, selected_chats, messages, photo, delay, callback_query.from_user.id))

    await callback_query.message.edit_text("<b>–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏:</b> –ê–∫—Ç–∏–≤–Ω–∞", reply_markup=get_mailing_control_keyboard(paused=False))

@dp.callback_query(F.data == "stop_mailing")
async def stop_mailing(callback_query: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—Å—Å—ã–ª–∫–∏."""
    user_id = callback_query.from_user.id

    if active_mailings.get(user_id):
        active_mailings[user_id] = False  # –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞—Å—Å—ã–ª–∫—É

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Ä–∞—Å—Å—ã–ª–∫–µ
        user_data = await state.get_data()
        photo = user_data.get('photo')  # –ü—É—Ç—å –∫ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –µ—Å–ª–∏ –±—ã–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞
        selected_chats = user_data.get('selected_chats')

        # –£–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
        if photo and os.path.exists(photo):
            os.remove(photo)  # –£–¥–∞–ª—è–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—Å—Å—ã–ª–∫–∏

        # –ü–æ–¥—Å—á—ë—Ç —Å–æ–æ–±—â–µ–Ω–∏–π
        sent_messages_count = len(selected_chats) - 1

        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—É—é —Ä–∞—Å—Å—ã–ª–∫—É –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        async with aiosqlite.connect('bot_database.db') as db:
            await db.execute('INSERT INTO mailings (user_id, chats, sent_messages, status, start_time) VALUES (?, ?, ?, ?, ?)',
                             (user_id, ','.join(str(c) for c in selected_chats), sent_messages_count, 'finished', datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
            await db.commit()

        # –°–æ–æ–±—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ–± —É—Å–ø–µ—à–Ω–æ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞—Å—Å—ã–ª–∫–∏
        await callback_query.message.edit_text("<b>–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏:</b> –ó–∞–≤–µ—Ä—à–µ–Ω–∞")
    else:
        # –ï—Å–ª–∏ —Ä–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞
        await callback_query.message.edit_text("<b>–û—à–∏–±–∫–∞:</b> –≠—Ç–∞ —Ä–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –±—ã–ª–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Ä–∞–Ω–µ–µ.")


# ================== –ó–ê–ü–£–°–ö –ë–û–¢–ê ===================

async def main():
    await init_db()
    asyncio.create_task(check_subscription_expiration())
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
